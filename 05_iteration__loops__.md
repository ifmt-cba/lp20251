# Chapter 5: Iteration (Loops)

Welcome back! In the [previous chapter](04_conditional_logic_.md), we learned about **Conditional Logic** (`if`, `elif`, `else`), which allows your program to make decisions and choose *which* code to run based on conditions. This is like telling a robot, "IF there's a wall in front of you, THEN turn left."

But what if you need the robot to perform the same action multiple times? For example, "Take 10 steps forward" or "Keep walking forward UNTIL you reach the door." Conditional logic isn't enough for this. You could write the instruction "take a step" ten times, but that's tedious and doesn't work if you don't know exactly how many steps are needed beforehand.

This is where **Iteration**, also known as **Looping**, comes in. Iteration is the programming concept that allows you to repeat a block of code multiple times. It's fundamental for automating repetitive tasks, processing lists of items (which we'll see in the next chapter!), or performing actions until a certain condition is met.

In Python, the two main types of loops are `for` loops and `while` loops. You'll find these used extensively in `lista3.py`, which focuses on exercises that require repeating actions.

## Why Use Loops? (The Power of Repetition)

Imagine you need to print the numbers from 1 to 5. Without loops, you'd write:

```python
print(1)
print(2)
print(3)
print(4)
print(5)
```

Simple enough for 5 numbers. But what about printing numbers from 1 to 100? Or 1 to 1000? Writing `print()` 1000 times is impractical and prone to errors. Loops solve this by allowing you to write the `print()` command just once and tell the program to repeat it.

Loops let you:

*   Perform an action a specific number of times.
*   Perform an action for each item in a sequence (like a list of names).
*   Perform an action until a certain condition is no longer true.

Let's look at the two main types of loops in Python.

## The `for` Loop: Repeating a Fixed Number of Times (or Over Items)

A `for` loop is typically used when you know in advance how many times you want to repeat a block of code, or when you want to go through each item in a sequence one by one.

The simplest way to use a `for` loop for a fixed number of repetitions is with the `range()` function. `range()` generates a sequence of numbers.

| `range()` Usage      | Numbers Generated (Sequence) |
| :------------------- | :--------------------------- |
| `range(stop)`        | 0, 1, 2, ..., `stop`-1       |
| `range(start, stop)` | `start`, `start`+1, ..., `stop`-1 |
| `range(start, stop, step)` | `start`, `start`+`step`, ..., (stops before `stop`) |

Let's revisit printing 1 to 5 using a `for` loop:

```python
# Print numbers from 1 to 5
for number in range(1, 6): # range(1, 6) gives us 1, 2, 3, 4, 5
    print(number)
```

**Explanation:**

*   `for number in range(1, 6):`: This is the `for` loop statement.
    *   `for`: The keyword that starts the loop.
    *   `number`: A variable name. In each repetition (or "iteration") of the loop, this variable will be assigned the *next* value from the `range()` sequence. You can choose any valid variable name here (like `i`, `x`, `count`, etc.).
    *   `in`: This keyword means "for each item in".
    *   `range(1, 6)`: This is the sequence the loop will iterate over. `range(1, 6)` generates the numbers 1, 2, 3, 4, and 5.
    *   `:`: A colon marks the end of the `for` line.
*   `print(number)`: This is the code block *inside* the loop. It's indented, just like `if` and `else` blocks. This line will be executed once for each number generated by `range(1, 6)`.

**How it works step-by-step:**

1.  The loop starts. Python gets the first number from `range(1, 6)`, which is `1`.
2.  The variable `number` is set to `1`.
3.  The code inside the loop (`print(number)`) runs, printing `1`.
4.  Python checks if there are more numbers in the `range`. Yes, `2` is next.
5.  The variable `number` is set to `2`.
6.  The code inside the loop runs, printing `2`.
7.  This repeats for `3`, `4`, and `5`.
8.  After printing `5`, Python checks `range(1, 6)` again. There are no more numbers.
9.  The loop finishes, and the program continues with any code written *after* the indented loop block.

This single `for` loop replaced 5 `print` lines! This becomes incredibly powerful for larger tasks.

Let's look at `q1` from `lista3.py`, which uses a simple `for` loop:

```python
# From lista3.py, q1
# 1.Faça um programa que imprima todos os números de 1 até 100.
def q1():
    for x in range(1, 101): # range(1, 101) generates numbers from 1 to 100
        print(x, end=' ') # Prints the number, followed by a space instead of a newline
```

This small code block prints numbers 1 through 100 using just two lines within the function. The `end=' '` inside `print` just makes the output appear on a single line separated by spaces, rather than each number on a new line.

`q2` and `q3` in `lista3.py` use `range` with the `step` argument to count downwards or by multiples:

```python
# From lista3.py, q2 (simplified)
# 2. Faça um programa que imprima todos os números pares de 100 até 1.
def q2_simplified():
    # Goes from 100 down to 2, stepping by -2
    for num in range(100, 0, -2):
        print(num, end=' ')

# From lista3.py, q3 (simplified)
# 3. Faça um programa que imprima os múltiplos de 5, no intervalo de 1 até 500.
def q3_simplified():
    # Goes from 0 (or 5) up to 500, stepping by 5
    for num in range(0, 501, 5): # Could also start at 5
        print(num, end=' ')
```

The `for` loop is excellent when you have a collection of items to process or a fixed number of repetitions.

## The `while` Loop: Repeating as Long as a Condition is True

A `while` loop is used when you want to repeat a block of code as long as a specific condition remains `True`. You don't necessarily know how many times it will run beforehand; it depends on when the condition becomes `False`.

Think of the "keep walking forward UNTIL you reach the door" instruction. The robot keeps walking (repeats the "take a step" action) as long as the condition "not at the door" is `True`.

The structure is simpler than a `for` loop, but you *must* make sure that something *inside* the loop will eventually make the condition `False`, otherwise you'll create an **infinite loop** (a loop that never stops!).

Here's a simple `while` loop example:

```python
# Count up from 0 to 4
count = 0 # Starting point

while count < 5: # Condition: keep looping as long as count is less than 5
    print(count)
    count = count + 1 # IMPORTANT: Change the variable used in the condition!

print("Loop finished.")
```

**Explanation:**

*   `count = 0`: We initialize a variable `count` that will be used in our condition.
*   `while count < 5:`: This is the `while` loop statement.
    *   `while`: The keyword that starts the loop.
    *   `count < 5`: This is the **condition**. The loop will continue to execute as long as this condition is `True`.
    *   `:`: A colon marks the end of the `while` line.
*   `print(count)`: Code inside the loop (indented). Prints the current value of `count`.
*   `count = count + 1`: Code inside the loop. This line is crucial! It increases the value of `count` by 1 in each iteration. This is how the condition `count < 5` will eventually become `False`.

**How it works step-by-step:**

1.  The variable `count` is set to `0`.
2.  Python checks the `while` condition: Is `0 < 5`? `True`.
3.  Code inside the loop runs: `print(0)` and `count` becomes `1`.
4.  Python checks the `while` condition again: Is `1 < 5`? `True`.
5.  Code inside the loop runs: `print(1)` and `count` becomes `2`.
6.  This repeats. When `count` is `4`, the condition `4 < 5` is `True`. `print(4)` runs, and `count` becomes `5`.
7.  Python checks the `while` condition again: Is `5 < 5`? `False`.
8.  The loop finishes. Python skips the loop's code block and executes the code after it (`print("Loop finished.")`).

`while` loops are great when you're waiting for a specific event or value, like reading user input until a certain number is entered, or performing a simulation until a state is reached.

Look at `q11` from `lista3.py`. It uses a `while` loop to read numbers until the user enters `0`:

```python
# From lista3.py, q11 (simplified)
# 11. Construa um programa que leia vários números ... Quando o valor 0 (zero) for lido, o algoritmo deverá cessar sua execução.
def q11_simplified():
    num = -1 # Initialize num with a value NOT equal to the stopping condition (0)
    contador = 0

    while num != 0: # Loop as long as num is NOT 0
        num = int(input('Digite um número inteiro (0 para parar): ')) # Get input, changes num
        if num >= 100 and num <= 200: # Use conditional logic INSIDE the loop!
            contador += 1 # Increment counter if the number is in the range

    print(f'Qtde de valores entre 100 e 200: {contador}')
```

In `q11_simplified`:

1.  `num` is initially set to `-1`, ensuring the `while num != 0:` condition is `True` and the loop starts.
2.  Inside the loop, the program *gets new input* from the user and stores it in `num`. This is the action that *might* make the loop condition `False`.
3.  If the user types `0`, in the next check of `while num != 0:`, the condition will be `False`, and the loop will stop.
4.  Conditional logic (`if num >= 100 and num <= 200:`) is used *within* the loop to process the input *during* each iteration.

This shows how loops and conditional logic often work together!

## `break` and `continue` (Quick Mention)

Sometimes you need more fine-grained control inside loops:

*   `break`: Immediately stops the *entire* loop, regardless of the loop condition, and jumps to the code *after* the loop.
*   `continue`: Skips the *rest* of the current iteration and jumps to the *next* iteration of the loop (checking the condition again for `while`, or getting the next item for `for`).

You can see `break` and `continue` used in the `exemploEnquanto` function in `lista3.py`, although they are less common for simple beginner exercises. Focus on understanding the basic `for` and `while` structure first.

## Loops in `qXX` Functions and `lista3.py`

`lista3.py` is designed to give you practice with these concepts. Each `qXX` function in `lista3.py` will use either a `for` loop or a `while` loop (or sometimes both) to solve a problem that requires repetition.

For example:

*   `q1`, `q2`, `q3`, `q6`: Use `for` loops to print sequences or generate terms.
*   `q4`, `q7`, `q8`: Use `for` loops because they need to process a *fixed* number of inputs (20 people, 15 students, 10 people).
*   `q5`: Uses a `for` loop to perform a fixed number of additions.
*   `q11`, `q12`, `q13`: Use `while` loops because the number of repetitions isn't fixed; they stop based on a condition (input is 0, population sizes compare differently).

When you run `lista3.py` and select an exercise number using the [Exercise Runner](01_exercise_runner_.md), the Runner simply calls the chosen `qXX` function (as learned in [Chapter 2](02_exercise_question__qxx_function__.md)). The loop code *inside* that function is then executed repeatedly according to its definition.

Here's a simple diagram showing the flow for a `qXX` function containing a loop:

```mermaid
sequenceDiagram
    participant User
    participant Exercise Runner
    participant qXX Function
    participant Loop Inside qXX

    User->>Exercise Runner: Runs lista3.py
    Exercise Runner->>User: Ask for exercise number
    User->>Exercise Runner: Type number (e.g., 1)
    Exercise Runner->>qXX Function: Call q1()
    qXX Function->>Loop Inside qXX: Start FOR loop (e.g., over range 1 to 100)
    Loop Inside qXX->>Loop Inside qXX: Check if there are more items/iterations
    Loop Inside qXX->>qXX Function: Execute code for current item/iteration
    qXX Function->>User: (May print output)
    Loop Inside qXX-->>Loop Inside qXX: (Repeat check and execute step)
    Loop Inside qXX->>qXX Function: No more items/condition False (Loop finishes)
    qXX Function-->>Exercise Runner: Function finishes
    Exercise Runner-->>User: Program finishes
```

This shows that the loop is simply one or more steps *within* the `qXX` function's overall task. The loop repeats its internal steps until it's done, then the `qXX` function continues (or finishes).

## Conclusion

In this chapter, you learned about **Iteration (Loops)**, the concept of repeating a block of code. You explored the two main types of loops in Python:

*   `for` loops, used for repeating a fixed number of times or iterating over a sequence (like numbers from `range()`).
*   `while` loops, used for repeating as long as a specific condition remains `True`, requiring careful management of the condition to avoid infinite loops.

You saw how these loops are used within the `qXX` functions in `lista3.py` to solve problems requiring repetitive actions.

Understanding loops is essential, as many programming tasks involve processing collections of data or waiting for specific events. In the next chapter, we'll look at how to store and manage collections of data, which are often processed using the loops you just learned!

[Next Chapter: Data Collections](06_data_collections_.md)

---

<sub><sup>Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge).</sup></sub> <sub><sup>**References**: [[1]](https://github.com/ifmt-cba/lp20251/blob/2353bfea16374996818c71298b449a71933ddc9f/lista3.py)</sup></sub>